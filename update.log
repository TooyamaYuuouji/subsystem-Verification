# 0.01v
VIP基本框架搭建完成

# 0.02v
修改driver，使其符合时序。加入timer能够使用的sequence和test

# 0.03v
加入virtual sequence和virtual sequencer机制，并修改了对应的文件索引等

# 0.04v
优化文件结构

# 0.05v(bug)
修改virtual sequence和virtual sequencer中的问题，避免出现两次发送的情况。
问题似乎出现在env中default_sequence处，其他sequence直接被绑定为virtual_seq进行发送，但不确定这是不是发送两次sequence的原因。
取消使用virtual sequence，改为test中直接指定使用virtual sequencer中的sequencer，不再发生该问题

# 0.06v(搁置)
修改dut，使用mux和其他组件组成dut。并修改对应的其他部分代码（driver、sequence、test等）使符合要求

# 0.07v
优化文件结构，给每一个外设都设置了对应的文件夹

# 0.08v
加入apb monitor和scoreboard。加入和dut输出有关的接口，增加并优化相关sequence，新sequence加入到timer_test中

# 0.10v
准备验证双端口timer，验证结构等与timer相同

# 0.20v
验证watchdog，验证结构等与timer相同

# 0.30v
验证uart，验证结构等与timer相同

# 0.31v
加入timer的寄存器模型。增加shell脚本，以批量生成寄存器模型。修改configuration，增加比较器。部分寄存器加入后门访问方式

# 0.32v
拆开，分别验证，所有子模块各自对应单独的验证环境。首先完成timer

# 0.33v(搁置)
仿照timer，完成watchdog

# 0.34v
仿照timer，完成dualtimer

# 0.35v
仿照timer，完成uart

# 1.00v

# 2.00v
加入subsystem的验证。搭建基本框架

# 2.01v
对timer0的基本功能进行了验证

# 2.02v
对timer1的基本功能进行了验证

# 2.03v
增加了virtual sequencer和p_sequencer的支持

# 2.04v
对dualtimer的基本功能进行了验证

# 2.05v
对uart0的基本功能进行了验证

# 2.06v
对uart1、uart2的基本功能进行了验证

# 2.07v
修改Makefile，增加回归测试和覆盖率的相关代码

# 2.08v
virtual sequencer增加interface变量供sequence使用。sequence分层并嵌套，增加defines

# 2.09v
简单测试了一下是否可以在timer0_internal_clock_seq中使用和ahbl_single_w32_seq一样的p_sequencer机制

# 2.10v
完善和timer0有关的sequence以及test

# 2.11v
完善和timer1有关的sequence以及test

# 2.12v
加入scoreboard，加入和timer0、timer1有关的功能验证断言

# 2.13v
完善和dualtimer有关的sequence以及test

# 2.14v
完善和uart有关的sequence以及test

## timer验证要点
内部寄存器的读写由PCLKG上升沿控制，而不是PCLK，这一点尤其要注意
PCLK应该由更上一级时钟生成，且上级时钟是双端时钟，方便PCLKG进行参考（PSEL和PENABLE可以上升沿触发，但与此同时的PCLKG必须在紧接着的一个时钟下降沿从零置一）

## dualtimer验证要点
TimerPre中的11模式——UNDEFINED，不是指不使用分频系数，相反，如果配置了该模式，很可能是随机给一个分频系数（未验证该猜想）

## uart验证要点
- tx时，地址必须保持不变，其他APB上的数据可以变化。直到tx发送完成后才能改变地址。- 
发生中断时，必须及时清空中断，否则该uart不会顺利发生数据。
在tx发送过程中，可以向uart写入下一次想要发送的数据，但该tx过程不会被打断，而是等待上一次的数据发送完成后再给出中断然后开始发送新数据。
最后一次数据的发送不会产生中断，换句话说，单次tx不产生发送完成中断，只在准备发送时产生中断
- tx的overrun中断产生时，似乎会以最后一次传输的数据作为tx发送的数据
- rx的overrun中断触发条件：传输了一次数据之后不进行读取操作，下一次数据传输完成后就会产生overrun中断

## pclkg
可以直接等于pclk。当然，按照规定，应该是使用pclk和apbactive生成pclkg，实现低功耗